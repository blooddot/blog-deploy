<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EgretPro 入门与踩坑</title>
    <url>/posts/93f2990b/</url>
    <content><![CDATA[<p>本篇文章主要是总结EgretPro入门和踩坑的经历。</p>
<a id="more"></a>
<h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><p>参考：<a href="https://docs.egret.com/egretpro/docs/guide/getting-started-install">https://docs.egret.com/egretpro/docs/guide/getting-started-install</a></p>
<p>确保引擎版本：egret engine版本是5.3.7+，egret pro版本是1.6.0+</p>
<h2 id="创建运行3D示例项目"><a href="#创建运行3D示例项目" class="headerlink" title="创建运行3D示例项目"></a>创建运行3D示例项目</h2><h3 id="3D项目-步骤"><a href="#3D项目-步骤" class="headerlink" title="3D项目-步骤"></a>3D项目-步骤</h3><ol>
<li>打开EgretPro，点击右边新建按钮，打开创建项目页面
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232255.png" alt="20210701232255"></li>
<li>选择项目目录路径后，点击右下角新建按钮创建项目</li>
<li>在egret Pro编辑器中点击顶部选择内置或者浏览器选项运行预览</li>
</ol>
<h3 id="3D项目-坑点"><a href="#3D项目-坑点" class="headerlink" title="3D项目-坑点"></a>3D项目-坑点</h3><ul>
<li>编辑器提示3000端口已被占用
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232556.png" alt="20210701232556">
  <strong>问题原因</strong>：因为EgretPro打开后会默认启动一个3000端口的http服务器，所以当3000端口被占用时会打开项目失败<br>  <strong>解决方案</strong>：一般造成这种原因是因为我们打开了egret项目进行调试。<ul>
<li>如果是没有用webpack方式打包的egret项目可以在egret run命令后加上–port参数指定端口号运行，避免冲突。</li>
<li>如果是webpack方式打包的egret项目，可以在scripts/config.ts文件中搜索port关键字修改启动时的默认端口号。</li>
<li>可否修改EgretPro编辑器的默认端口？EgretPro是在Egret3D引擎源码的toolkit/compiler/compiler.js文件中设置的，搜索web: 3000可以查询到，但是修改后编辑器会有其他问题，暂时没有找正确的修改方式</li>
</ul>
</li>
</ul>
<h2 id="创建运行2D嵌套3D示例项目"><a href="#创建运行2D嵌套3D示例项目" class="headerlink" title="创建运行2D嵌套3D示例项目"></a>创建运行2D嵌套3D示例项目</h2><h3 id="2D项目-步骤"><a href="#2D项目-步骤" class="headerlink" title="2D项目-步骤"></a>2D项目-步骤</h3><ol>
<li><p>创建2D项目</p>
</li>
<li><p>将3D项目拷贝到2D项目根目录</p>
</li>
<li><p>进入到3D项目，运行npm install 或者 yarn 安装依赖库</p>
</li>
<li><p>修改3D项目中的package.json中的build:library命令</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;build:library&quot;: &quot;egret-pro build . --target pro-library&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3D项目中的egretpro.json添加resourceRoot属性</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;resourceRoot&quot;: &quot;[3D项目目录名]/resource/&quot;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>3D项目中的egretpro.json文件targets对象添加如下属性</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pro-library&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;projectRoot&quot;</span>: <span class="string">&quot;./pro-library&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3D项目中运行 build:library命令，将3D项目代码打包成pro-library库供2D项目使用</p>
</li>
<li><p>将3D项目中libs/modules的oimo和box2d文件夹库拷贝到2D项目中的libs目录中</p>
</li>
<li><p>2D项目的index.html和template/index.html中egret.runEgret方法添加pro: true选项</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">egret.runEgret(&#123;</span><br><span class="line">    renderMode: <span class="string">&quot;webgl&quot;</span>, <span class="attr">audioType</span>: <span class="number">0</span>, <span class="attr">calculateCanvasScaleFactor</span>: <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> backingStore = context.backingStorePixelRatio ||</span><br><span class="line">            context.webkitBackingStorePixelRatio ||</span><br><span class="line">            context.mozBackingStorePixelRatio ||</span><br><span class="line">            context.msBackingStorePixelRatio ||</span><br><span class="line">            context.oBackingStorePixelRatio ||</span><br><span class="line">            context.backingStorePixelRatio || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>) / backingStore;</span><br><span class="line">    &#125;,</span><br><span class="line">    pro: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>egretProperties.json文件中添加以下选项，用于编译3D项目生成的代码到2D项目中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pro-library&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;./egret-3D-demo/pro-library&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Main.ts中的onButtonClick方法，用于显示3D内容到2D项目中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">onButtonClick</span>(<span class="params">e: egret.TouchEvent</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> texture = <span class="keyword">await</span> egret.pro.createTextureFrom3dScene(<span class="string">&quot;assets/scenes/box2ds/test.scene.json&quot;</span>, <span class="number">640</span>, <span class="number">1136</span>);</span><br><span class="line">    <span class="keyword">const</span> bitmap = <span class="keyword">new</span> egret.Bitmap(texture);</span><br><span class="line">    <span class="built_in">this</span>.addChild(bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2D项目运行egret build -e 编译库</p>
</li>
<li><p>2D项目运行egret run查看3D项目在2D中的表现</p>
</li>
</ol>
<h3 id="2D项目-坑点"><a href="#2D项目-坑点" class="headerlink" title="2D项目-坑点"></a>2D项目-坑点</h3><ul>
<li><p>运行build:library时报错
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232703.png" alt="20210701232703"></p>
</li>
<li><p>*问题原因**：macOS使用的换行符LF，安装的egret库中的运行脚本是CRLF格式，导致运行node命令时解析出错  </p>
</li>
<li><p>*解决方案**：用vscode打开3D项目中的node_modules/.bin/egret-pro文件，右下角将换行符格式改为LF并保存
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232724.png" alt="20210701232724"></p>
</li>
<li><p>编译库报错
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232817.png" alt="20210701232817"></p>
</li>
<li><p>*问题原因**：2D项目用的Typescript版本太低了，InstanceType是Typescript2.8+的功能  </p>
</li>
<li><p>*解决方案**：只是Box2D.d.ts描述文件用了这个特性，可以先将报错处的InstanceType&lt;T&gt;改成any或者new ()=&gt; T</p>
</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li><p>egretProUtil为空
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232835.png" alt="20210701232835">
index.html 没有开启pro选项导致，参考步骤9解决</p>
</li>
<li><p>3D场景加载失败
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232854.png" alt="20210701232854">
场景资源路径错误，参考步骤5和11解决</p>
</li>
<li><p>OIMO，Box2D库找不到
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232909.png" alt="20210701232909">
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232924.png" alt="20210701232924">
2D工程没有添加对应库，参考步骤8解决</p>
</li>
</ul>
<h2 id="2D项目与3D项目通信"><a href="#2D项目与3D项目通信" class="headerlink" title="2D项目与3D项目通信"></a>2D项目与3D项目通信</h2><h2 id="2D发消息到3D"><a href="#2D发消息到3D" class="headerlink" title="2D发消息到3D"></a>2D发消息到3D</h2><ul>
<li><p>2D项目发送消息代码</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送消息方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>command 消息名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>target 目标对象，填写一个数字即可，保证发送到对象和接受对象一致</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">egret.pro.dispatch(command: <span class="built_in">string</span>, <span class="attr">target</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3D项目接收消息代码</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听消息方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>eventType 消息名称，对应2D发送到消息名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>target 目标对象，对应2D发送的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>func 执行方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>thisObject 方法作用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Application.instance.egretProUtil.addEventListener(eventType: <span class="built_in">string</span>, <span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">func</span>: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">thisObject</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>args 对应发送消息的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func(...args: <span class="built_in">any</span>[]): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3D发消息到2D"><a href="#3D发消息到2D" class="headerlink" title="3D发消息到2D"></a>3D发消息到2D</h2><ul>
<li><p>3D项目发送消息代码</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送消息方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>command 消息名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>target 目标对象，填写一个数字即可，保证发送到对象和接受对象一致</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Application.instance.egretProUtil.dispatch(command: <span class="built_in">string</span>, <span class="attr">target</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2D项目接收消息代码</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听消息方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>eventType 消息名称，对应2D发送到消息名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>target 目标对象，对应2D发送的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>func 执行方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>thisObject 方法作用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">egret.pro.addEventListener(eventType: <span class="built_in">string</span>, <span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">func</span>: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">thisObject</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>args 对应发送消息的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">func(...args: <span class="built_in">any</span>[]): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h2><h3 id="发布项目-步骤"><a href="#发布项目-步骤" class="headerlink" title="发布项目-步骤"></a>发布项目-步骤</h3><p>运行egret publish命令进行打包</p>
<h3 id="发布项目-坑点"><a href="#发布项目-坑点" class="headerlink" title="发布项目-坑点"></a>发布项目-坑点</h3><ul>
<li><p>提示box2d.min.js文件找不到
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701232943.png" alt="20210701232943"></p>
</li>
<li><p>*问题原因**：白鹭打包实用的库文件是min.js文件，由于我们拷贝过来的box2d库只有box2d.js，并没有box2d.min.js文件  </p>
</li>
<li><p>*解决方案**：在libs/box2d目录下生成min.js文件，最快速简单的解决方法是拷贝一份box2d.js重命名为box2d.min.js</p>
</li>
<li><p>提示pro-library.min.js文件找不到
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233044.png" alt="20210701233044"></p>
</li>
<li><p>*问题原因**：同上  </p>
</li>
<li><p>*解决方案**：在 [3D项目目录名]/pro-library/文件夹下，生成pro-library.min.js。但要注意的是，这个文件包含了3D项目的代码，每次3D项目改完后，要执行build:library命令打包代码，如果要打包2D项目，要每次都拷贝覆盖一份pro-library.min.js文件保证此文件是最新的</p>
</li>
</ul>
<h2 id="创建运行-iOS工程"><a href="#创建运行-iOS工程" class="headerlink" title="创建运行 iOS工程"></a>创建运行 iOS工程</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>egret的iOS原生项目运行3D的原理实际上是创建了一个webview，用于渲染web服务器上的3D场景，3D项目的渲染本质上还是走的H5形式，并非原生渲染的形式</li>
<li>所以我们要有一个web服务器用于存放3D资源进程调试</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>修改3D项目中egretpro.json文件的resourceRoot属性，注意前面的IP和端口号为你的本地IP和2D项目本地调试时候的端口号</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;resourceRoot&quot;: &quot;&lt;http://192.168.31.28:8888/[3D&gt;项目目录名]/resource/&quot;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行2D项目调试，会启动一个web服务器，确保3D项目的资源可以通过web访问到</p>
</li>
<li><p>打开egret launcher软件，选择2D项目，点击发布设置，填写应用名称和应用包名
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233128.png" alt="20210701233128"></p>
</li>
<li><p>点击确认后会在2D项目的同目录生成iOS工程项目</p>
</li>
<li><p>实用xcode打开该项目</p>
</li>
<li><p>打开AppDelegate.mm文件，将_native.config.disableNativeRender设为true
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233149.png" alt="20210701233149"></p>
</li>
<li><p>选择模拟器，运行调试查看效果</p>
</li>
</ol>
<h2 id="真机运行"><a href="#真机运行" class="headerlink" title="真机运行"></a>真机运行</h2><ol>
<li>确保模拟器运行正确的情况下，连接iPhone到Mac并信任</li>
<li>Xcode选择左上角Xcode -&gt; Preferences -&gt; Accounts界面，登录Apple ID</li>
<li>选择右下角Manage Certificates按钮
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233208.png" alt="20210701233208"></li>
<li>打开证书界面后，点击左下角添加证书
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233226.png" alt="20210701233226"></li>
<li>打开项目设置界面，选择对应开发组
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233242.png" alt="20210701233242"></li>
<li>点击顶部选择 iPhone设备进行调试
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233258.png" alt="20210701233258"></li>
<li>首次调试时，iPhone设备要信任证书文件，访问允许网络，可访问web的3D资源（调试时在同一个局域网下即可）</li>
</ol>
<h2 id="使用Egret3DExportTools"><a href="#使用Egret3DExportTools" class="headerlink" title="使用Egret3DExportTools"></a>使用Egret3DExportTools</h2><h3 id="Egret3DExportTools-说明"><a href="#Egret3DExportTools-说明" class="headerlink" title="Egret3DExportTools-说明"></a>Egret3DExportTools-说明</h3><p>egret官方有提供Egret3DExportTools工具用于Unity3D中的场景资源导出</p>
<p>github地址：<a href="https://github.com/egret-labs/egret3d-unityplugin">https://github.com/egret-labs/egret3d-unityplugin</a></p>
<h3 id="Egret3DExportTools-步骤"><a href="#Egret3DExportTools-步骤" class="headerlink" title="Egret3DExportTools-步骤"></a>Egret3DExportTools-步骤</h3><p>安装和使用，参考：<a href="https://docs.egret.com/egretpro/docs/spec/unity-assets">https://docs.egret.com/egretpro/docs/spec/unity-assets</a></p>
<h2 id="Egret3DExportTools-坑点"><a href="#Egret3DExportTools-坑点" class="headerlink" title="Egret3DExportTools-坑点"></a>Egret3DExportTools-坑点</h2><ul>
<li><p>导出资源名中有_#加载会失败</p>
<p>  <strong>问题原因</strong>：可能和egret资源配置加载有关，具体原因未知</p>
<p>  <strong>解决方案</strong>：在Unity中先重命名后再导出</p>
</li>
<li><p>Unity项目设置的模型Shader类型，导出时请确保设置为Unity的格式</p>
</li>
</ul>
<h2 id="附加问题"><a href="#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><h3 id="动画播放完毕回调"><a href="#动画播放完毕回调" class="headerlink" title="动画播放完毕回调"></a>动画播放完毕回调</h3><ul>
<li><strong>问题描述</strong>：在做项目时，发现实体添加了Animation组件后，播放动画时，想要监听动画完成的事件官方文档中没有提供</li>
<li><strong>解决思路</strong><ul>
<li>查看官方api说明，并且查看引擎源码，发现有一个AnimationEventType的定义</li>
<li>全局搜索AnimationEventType没有发现用法，只发现了该对象的枚举值定义</li>
<li>精简搜索关键字，只搜索AnimationEvent，发现官方示例的AnimationHelper类中有一个onAnimationEvent方法，猜测可能是用于动画状态的回调</li>
<li>搜索onAnimationEvent方法，发现在Animation源码目录中会派发相应的onAnimationEvent消息出来</li>
<li>测试后发现果然onAnimationEvent方法是绑定在实体上面的动画回调方法</li>
<li>该方法的参数类型为AnimationEvent，其中的type属性就是对应的AnimationEventType的枚举值（不过定义文件却是string类型，匪夷所思）</li>
</ul>
</li>
</ul>
<h3 id="EgretPro编辑器添加tag"><a href="#EgretPro编辑器添加tag" class="headerlink" title="EgretPro编辑器添加tag"></a>EgretPro编辑器添加tag</h3><ul>
<li><strong>问题描述</strong>：添加多个实体后，我想给不同的实体添加tag，发现只能使用导出时预制的那几个tag，不能像Unity那样添加</li>
<li><strong>解决思路</strong><ul>
<li>最简单的解决方法，在Unity中添加tag，再重新导出</li>
<li>但是导出后会把我原本的EgretPro场景覆盖，又要重新搭建，效率不高</li>
<li>猜测tag应该是作为某个配置文件保存在项目本地的，所以项目全局搜索一个tag值，并没有搜索到有用的信息</li>
<li>猜测tag值可能保存在编辑器中，而非项目中</li>
<li>编辑器目录中搜索一个tag值，发现有用信息
<img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210701233319.png" alt="20210701233319"></li>
<li>原来tag值是配置在引擎库packages/engine目录下的文件</li>
<li>分别在index.d.ts和index.js文件中添加我们想要的tag值</li>
<li>重启EgretPro，发现我们添加的tag值果然生效了</li>
</ul>
</li>
</ul>
<h2 id="onCollisionEnter方法不生效"><a href="#onCollisionEnter方法不生效" class="headerlink" title="onCollisionEnter方法不生效"></a>onCollisionEnter方法不生效</h2><ul>
<li><strong>问题描述</strong>：因为EgretPro设计思路很多都是借鉴Unity，所以碰撞代码我就直接用onCollisionEnter方法去实现，而且egret中也确实声明了onCollisionEnter方法，但是使用时却没有生效</li>
<li><strong>解决思路</strong><ul>
<li>检查代码，并没有写错的感觉</li>
<li>查看引擎源码，发现虽然d.ts中声明了onCollisionEnter，但是js源码中却并未实现，还是TODO状态，有点坑呀</li>
<li>看来碰撞检测不能用简单的onCollisionEnter方式做了</li>
<li>查看示例和源码发现有CollisionManager类，用于专门管理碰撞</li>
<li>该类附带了raycast，raycastSingle，raycastAll三个方法，分别用于检测碰撞组件返回boolean值，检测单个实体对象，检测所有碰撞组件并返回精确信息</li>
<li>raycast是我想要的方法，但我想要获取到碰撞后的实体，不只是要一个boolean值，查看方法发现最后一个参数RaycastInfo传入后，可以赋值碰撞信息</li>
<li>所以传入了后面两个附加参数maxDistance和RaycastInfo</li>
<li>结果却出现了传入参数后和传入参数前结果不一致的情况</li>
<li>查看源码发现传入数maxDistance和RaycastInfo后会多走一些逻辑</li>
<li>其实源码里面已经找到碰撞的实体了，只是返回的是boolean值而已</li>
<li>我修改了源码返回值，直接把实体返回，达到想要的效果</li>
<li>并且比传入maxDistance和RaycastInfo效率还高</li>
</ul>
</li>
</ul>
<h2 id="项目Github地址"><a href="#项目Github地址" class="headerlink" title="项目Github地址"></a>项目Github地址</h2><p><a href="https://github.com/blooddot/egret-2d-demo">https://github.com/blooddot/egret-2d-demo</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.egret.com/egretpro/docs/guide/getting-started-install">安装 Egret Pro</a></li>
<li><a href="https://docs.egret.com/egretpro/video">Egret Pro视频教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/XZ3jSxY9tTFWRLMzbVY5JQ">Egret Pro 将3D项目发布成Native</a></li>
<li><a href="https://blog.csdn.net/jiuyuefenglove/article/details/117695587">EgretPro——入门全踩坑</a></li>
</ul>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/93f2990b/">https://blooddot.cool/posts/93f2990b/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>egret</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-builder使用简介</title>
    <url>/posts/1867545/</url>
    <content><![CDATA[<p>使用electron, 打包必不可免, 官方推荐electron-builder库进行应用打包.<br>本篇主要就工作中用到的electron-builder打包功能进行总结.</p>
<a id="more"></a>

<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>项目目录执行命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D electron-builder</span><br></pre></td></tr></table></figure>

<h2 id="二、构建配置"><a href="#二、构建配置" class="headerlink" title="二、构建配置"></a><a href="https://www.electron.build/configuration/configuration">二、构建配置</a></h2><p>可以直接在package.json中配置,也可以添加electron-builder.yml(yml,json5,toml,js)文件进行配置,以package.json配置为例  </p>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &#123;</span><br><span class="line">  &quot;productName&quot;: &quot;xxxx&quot;,  //String - 项目名,这也是生成的exe文件的前缀名</span><br><span class="line">  &quot;copyright&quot;:&quot;Copyright © year $&#123;author&#125;&quot;, //String - 版权信息</span><br><span class="line"></span><br><span class="line">  <span class="comment">//目录配置</span></span><br><span class="line">  &quot;directories&quot;: &#123;              </span><br><span class="line">    &quot;buildResources&quot;: &quot;build&quot;,  //String - 构建用的资源目录（不会包含在打包后的资源中, 例如nsis要用到的构建配置文件）</span><br><span class="line">    &quot;output&quot;: &quot;dist&quot;, //String - 输出文件夹, 默认输出到dist文件夹</span><br><span class="line">    &quot;app&quot;: &quot;app&quot;, //String  - 应用程序目录, 默认是app,www或工作空间</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  &quot;buildDependenciesFromSource&quot;: false,   //Boolean - 是否用源编译开发依赖项</span><br><span class="line">  &quot;nodeGypRebuild&quot;: false,        //Boolean - 是否每次打包前都重新构建node-gyp</span><br><span class="line">  &quot;npmArgs&quot;: [&quot;xxx&quot;],         //Array&lt;String&gt; | String - 直译: 安装应用程序本地依赖（native deps） 时添加的额外命令行参数, 原文: Additional command line arguments to use when installing app native deps. </span><br><span class="line">  &quot;npmRebuild&quot;: true,         //Boolean - 是否在打包应用程序之前重新构建本地依赖</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  &quot;buildVersion&quot;: &quot;xxxx&quot;,     //String - 构建的版本, 对应于MacOS 的CFBundleVersion 和 Windows 元数据属性，默认对应Version, 如果已经定义TRAVIS_BUILD_NUMBER 、 APPVEYOR_BUILD_NUMBER 、 CIRCLE_BUILD_NUM 、 BUILD_NUMBER 、 bamboo.buildNumber 这些环境变量，那么将会被用作 build Version（version.build_number）</span><br><span class="line">  &quot;electronCompile&quot;: true,    //Boolean - 是否使用 electron-compile 来编译应用程序, 注:electronCompile已废弃</span><br><span class="line">  &quot;electronDist&quot;: &quot;~/electron/out/R&quot;, //String - 自定义electron构建路径</span><br><span class="line">  &quot;electronDownload&quot;: &#123; //electron-download 选项  详见:&lt;https://github.com/electron/get#usage&gt;</span><br><span class="line">    &quot;version&quot;: &quot;xxx&quot;, //String - 版本</span><br><span class="line">    &quot;cache&quot;: &quot;xxxx&quot;,  //String - 缓存位置</span><br><span class="line">    &quot;mirror&quot;: &quot;xxxx&quot;, //镜像</span><br><span class="line">    &quot;strictSSL&quot;: false, //Boolean</span><br><span class="line">    &quot;isVerfyChecksum&quot;: false, //Boolean</span><br><span class="line">    &quot;platform&quot;:&quot;xxx&quot;, //“darwin” | “linux” | “win32” | “mas”</span><br><span class="line">    &quot;arch&quot;:&quot;xxxx&quot; //String</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;electronVersion&quot;:  &quot;xxx&quot;,    //String - 打包用的electron版本, 默认为electron electron-prebuilt electron-prebuilt-compile 依赖版本</span><br><span class="line">  &quot;extends&quot;: &quot;xxx&quot;, //String - 内置预设配置或配置文件的路径（相对于项目目录）当前只支持react-cra,如果安装了react-scripts依赖, react-cra会被自动设置，设置为null可以禁用自动检测</span><br><span class="line">  &quot;extraMetadata&quot;: &quot;xxx&quot;, //any - 注入额外属性到package.json中</span><br><span class="line">  &quot;readonly&quot;: false, //Boolean - 应用签名失败时,是否构建失败(用于停止构建签名失败的应用程序) </span><br><span class="line">  &quot;nodeVersion&quot;: &quot;current&quot;, //String - 仅限于libui-based frameworks ，打包所用的NodeJS版本，设置current表示当前运行的NodeJS版本</span><br><span class="line">  &quot;launchUiVersion&quot;: &quot;&quot;, //Boolean | String - 仅限于libui-based frameworks, 你所要打包的 LaunchUI 版本. 仅仅针对于Windows, 默认为适合框架使用的版本</span><br><span class="line">  &quot;framework&quot;: &quot;electron&quot;, //String - 框架名称，electron proton-native libui 默认为electron</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Hooks </span></span><br><span class="line">  &quot;afterPack&quot;: &quot;xxxx&quot;,  //打包后(签名前)执行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;afterSign&quot;: &quot;xxxx&quot;,  //签名后(打包成发行版之前)执行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;artifactBuildStarted&quot;: &quot;xxxx&quot;,   //artifact build(待理解)开始时执行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;artifactBuildCompleted&quot;: &quot;xxxx&quot;,   //artifact build(待理解)完成时执行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;afterAllArtifactBuild&quot;: &quot;xxxx&quot;,    //所有artifact build(待理解)运行完后执行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;onNodeModuleFile&quot;: &quot;xxxx&quot;,         //要在每个节点模块文件上运行的函数(文件或模块id的路径)</span><br><span class="line">  &quot;beforeBuild&quot;: &quot;xxxx&quot;,              //只有npmRebuild配置设置为true时生效, 依赖库被安装或重新编译后执行的函数(文件或模块id的路径).</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  &quot;remoteBuild&quot;: true,          //Boolean - 当前操作系统不支持构建时,使用Electron远程服务构建</span><br><span class="line">  &quot;includePdb&quot;: false,          //Boolean - 是否包含PDB文件(&lt;https://en.wikipedia.org/wiki/Program_database&gt;)</span><br><span class="line">  &quot;removePackageScripts&quot;: true,   //Boolean - 是否从package.json中移除scripts项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述的基本配置,对应不同的平台,还可以有不同的配置参数,如下:  </p>
<h3 id="MacOS平台配置"><a href="#MacOS平台配置" class="headerlink" title="MacOS平台配置"></a>MacOS平台配置</h3><ul>
<li>mac: MacOS平台构建选项, <a href="https://www.electron.build/configuration/mac">详见</a>  </li>
<li>mas: Mac应用程序商店构建选项, <a href="https://www.electron.build/configuration/mas">详见</a>  </li>
<li>dmg: Mac dmg包构建选项, <a href="https://www.electron.build/configuration/dmg">详见</a>  </li>
<li>pkg: Mac pkg包构建选项, <a href="https://www.electron.build/configuration/pkg">详见</a>  </li>
</ul>
<h3 id="Window平台配置"><a href="#Window平台配置" class="headerlink" title="Window平台配置"></a>Window平台配置</h3><ul>
<li>win: Windows平台构建选项, <a href="https://www.electron.build/configuration/win">详见</a>  </li>
<li>nsis: nsis 构建选项, <a href="https://www.electron.build/configuration/nsis">详见</a>  </li>
<li>nsisWeb: nsis web安装包构建选项, 继承自nsis构建选项, <a href="https://www.dazhuanlan.com/2019/10/10/5d9ef51ae2c29/">详见</a>  </li>
<li>appx: Windows应用程序商店构建选项, <a href="https://www.electron.build/configuration/appx">详见</a>  </li>
<li>squirrelWindows: 已废弃</li>
</ul>
<h3 id="Linux平台配置"><a href="#Linux平台配置" class="headerlink" title="Linux平台配置"></a>Linux平台配置</h3><ul>
<li>linux: Linux平台构建选项, <a href="https://www.electron.build/configuration/linux">详见</a>  </li>
<li>deb: Linux deb包构建选项, <a href="https://www.electron.build/configuration/linux#de">详见</a>  </li>
<li>snap: Linux snap包构建选项, <a href="https://www.electron.build/configuration/snap">详见</a>  </li>
<li>appImage: Linux appImage包构建选项, <a href="https://www.electron.build/configuration/linux#appimageoptions">详见</a>  </li>
<li>rpm: Linux rpm包构建选项, <a href="https://www.electron.build/configuration/linux#LinuxTargetSpecificOptions">详见</a>  </li>
<li>freebsd: Linux freebsd包构建选项, <a href="https://www.electron.build/configuration/linux#LinuxTargetSpecificOptions">详见</a>  </li>
<li>p5p: Linux p5p包构建选项, <a href="https://www.electron.build/configuration/linux#LinuxTargetSpecificOptions">详见</a></li>
<li>apk: Linux apk包构建选项, <a href="https://www.electron.build/configuration/linux#LinuxTargetSpecificOptions">详见</a></li>
</ul>
<h3 id="既能配置在build项-又能在每个平台中复写的配置"><a href="#既能配置在build项-又能在每个平台中复写的配置" class="headerlink" title="既能配置在build项, 又能在每个平台中复写的配置"></a>既能配置在build项, 又能在每个平台中复写的配置</h3><ul>
<li><p><strong>appId</strong> = com.electron.${name} String - 应用程序id</p>
</li>
<li><p><strong>artifactName</strong> String - 构建生成的文件名字模板, 默认为 ${productName}-${version}.${ext} (有些平台会有不同的默认值,具体查看各自平台的配置)  </p>
</li>
<li><p><strong>compression</strong> = normal “store” | “normal” | “maximum” - 压缩等级 如果要快速测试构建，store 能够显著地缩短构建时间，maximum 不会导致明显的尺寸差异，但是会增加构建时间。</p>
</li>
<li><p><strong>files</strong> Array&lt;String | FileSet&gt; | String | FileSet - 打包包含文件 默认包含项目根目录文件</p>
</li>
<li><p><strong>extraResources</strong> Array&lt;String |FileSet&gt; | String | FileSet - 外部资源路径,项目目录相对路径,拷贝匹配的目录或文件到应用程序资源目录下(对于MacOS是Contents/Resources, 对于Linux和Windows是resources)  </p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">FileSet = &#123;</span><br><span class="line">  &quot;from&quot;: &quot;./extraResources/&quot;,    //来源路径</span><br><span class="line">  &quot;to&quot;: &quot;extraResources&quot;          //目标路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>extraFiles</strong> Array&lt;String | FileSet&gt; | String | FileSet - 和extraResources类似,只是拷贝目标目录是应用程序内容目录(对于MacOS是Contents,对于Linux和Windows是根目录)</li>
<li><strong>asar</strong> AsarOptions | Boolean - 是否打包程序源代码为Electron的压缩包格式</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">AsarOptions = &#123;</span><br><span class="line">  &quot;smartUnpack&quot;: true,        //是否自动不打包可执行文件</span><br><span class="line">  &quot;ordering&quot;: &quot;xxxx&quot;,         //string</span><br><span class="line">  &quot;asarUnpack&quot;: [             //Array&lt;String&gt;|String 相对于项目目录,指定哪些文件不需要打包进压缩包内</span><br><span class="line">    <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fileAssociations</strong> Array&lt;FileAssociation&gt; | FileAssociation - 关联文件(特定格式的文件,双击后用此应用程序打开)</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">FileAssociation = &#123;</span><br><span class="line">  &quot;ext&quot;: &quot;xxxx&quot;, //文件扩展名, 例如png</span><br><span class="line">  &quot;name&quot;: &quot;xxxx&quot;, //名称, 例如PNG, 默认为ext同配置</span><br><span class="line">  &quot;description&quot;: &quot;xxxx&quot;, //只支持Windows操作系统, 文件描述</span><br><span class="line">  &quot;mimeType&quot;: &quot;xxxx&quot;,    //只支持Linux操作系统, 媒体类型</span><br><span class="line">  &quot;icon&quot;: &quot;xxxx&quot;,   //icon路径(MacOS为icns格式, Windows为ico格式), 构建用的资源目录的相对路径, Linux不支持</span><br><span class="line">  &quot;role&quot;:&quot;Editor&quot;,  //只支持MacOS The app’s role with respect to the type 可选值: Editor, Viewer, Shell, None.</span><br><span class="line">  &quot;isPackage&quot;: false,   //只支持MacOS Whether the document is distributed as a bundle. If set to true, the bundle directory is treated as a file. Corresponds to LSTypeIsPackage.</span><br><span class="line">  &quot;protocols&quot;:[&quot;xxxx&quot;], // Array&lt;Protocol&gt; | Protocol - The URL protocol schemes.</span><br><span class="line">  &quot;schemes&quot;:[&quot;xxxx&quot;], // Array&lt;String&gt; - The schemes. e.g. [&quot;irc&quot;, &quot;ircs&quot;].</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>forceCodeSigning</strong> Boolean - 当应用程序签名失败时, 是否打包失败</li>
<li><strong>electronUpdaterCompatibility</strong> = “&gt;=2.15” String - electronUpdater兼容版本, e.g. &gt;= 2.16, &gt;=1.0.0.</li>
<li><strong>publish</strong> 发布设置 <a href="https://www.electron.build/configuration/publish">详见</a></li>
<li><strong>detectUpdateChannel</strong> = true Boolean - (待理解) Whether to infer update channel from application version pre-release components. e.g. if version 0.12.1-alpha.1, channel will be set to alpha. Otherwise to latest.</li>
<li><strong>generateUpdatesFilesForAllChannels</strong> = false Boolean - (待理解) Please see Building and Releasing using Channels.</li>
<li><strong>releaseInfo</strong> releaseInfo - 发布信息. 用于命令行使用:  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c.releaseInfo.releaseNotes=<span class="string">&quot;new features&quot;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">releaseInfo = &#123;</span><br><span class="line">  &quot;releaseName&quot;:&quot;xxxx&quot;, //String - 发行名称</span><br><span class="line">  &quot;releaseNotes&quot;:&quot;xxxx&quot;, //String - 发行说明</span><br><span class="line">  &quot;releaseNotesFile&quot;:&quot;xxxx&quot;, //String - 发行说明文件, 默认为release-notes-$&#123;platform&#125;.md (platform值为当前平台 — mac, linux or windows) 或者 release-notes.md 保存在build resources目录下面.</span><br><span class="line">  &quot;releaseDate&quot;:&quot;xxxx&quot;, //String - 发行时间</span><br><span class="line">  &quot;target&quot;:&quot;&quot;   //String | TargetConfiguration 测试后,发现已不存在该字段</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、命令及参数"><a href="#三、命令及参数" class="headerlink" title="三、命令及参数"></a><a href="https://www.electron.build/cli">三、命令及参数</a></h2><p>package.json文件中添加打包执行脚本(以windows 64位包为例)  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">electron-builder --win --x64</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>electron-builder build                    构建应用 [默认值]<br>electron-builder install-app-deps         下载app依赖<br>electron-builder node-gyp-rebuild         重建自己的本机代<br>electron-builder create-self-signed-cert  为Windows应用程序创建自签名代码签名证书<br>electron-builder start                    使用electronic-webpack在开发模式下运行应用程序(需要electron-webpack模块支持)  </p>
<h3 id="构建参数"><a href="#构建参数" class="headerlink" title="构建参数"></a>构建参数</h3><p>–mac, -m, -o, –macos   为macOS平台构建 [array]<br>–linux, -l              为linux平台构建 [array]<br>–win, -w, –windows     为windows平台构建 [array]<br>–x64                    构建64位安装包 [boolean]<br>–ia32                   构建32位安装包 [boolean]<br>–armv7l                 构建armv7l安装包 [boolean]<br>–arm64                  构建arm64安装包 [boolean]<br>–dir                    只构建未打包目录. 对于测试特别有用 [boolean]<br>–prepackaged, –pd      预打包应用程序的路径（以可分发的格式打包）(这个参数有点难以理解, <a href="https://www.electron.build/#pack-only-in-a-distributable-format">详见</a>)<br>–projectDir, –project  项目目录的路径。 默认为当前工作目录。<br>–config, -c             配置文件路径。 默认为<code>electron-builder.yml</code>（或<code>js</code>, 或<code>js5</code>), <a href="https://goo.gl/YFRJOM">详见</a>  </p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>–publish, -p  发布到GitHub Releases [选项: “onTag”, “onTagOrDraft”, “always”, “never”, undefined]</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>–help     显示帮助 [boolean]<br>–version  显示当前版本号 [boolean]  </p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>electron-builder –win –x64    构建windows 64位版本<br>electron-builder -mwl           为macOS, Windows和Linux构建（同时构建）</p>
<h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><p><a href="https://www.electron.build/">https://www.electron.build/</a><br><a href="https://github.com/electron-userland/electron-builder">https://github.com/electron-userland/electron-builder</a><br><a href="https://github.com/QDMarkMan/CodeBlog/blob/master/Electron/electron-builder%E6%89%93%E5%8C%85%E8%AF%A6%E8%A7%A3.md">https://github.com/QDMarkMan/CodeBlog/blob/master/Electron/electron-builder%E6%89%93%E5%8C%85%E8%AF%A6%E8%A7%A3.md</a>
<a href="https://stackoverflow.com/questions/54978918/what-is-the-purpose-of-buildresources-folder-in-electron-builder-building-proces">https://stackoverflow.com/questions/54978918/what-is-the-purpose-of-buildresources-folder-in-electron-builder-building-proces</a>
<a href="https://blog.csdn.net/qq_38830593/article/details/89843722">https://blog.csdn.net/qq_38830593/article/details/89843722</a>
<a href="https://forum.snapcraft.io/t/how-do-i-make-the-polarr-snap-associate-with-image-files/7316">https://forum.snapcraft.io/t/how-do-i-make-the-polarr-snap-associate-with-image-files/7316</a></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/1867545/">https://blooddot.cool/posts/1867545/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>electron</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>git branch常用操作</title>
    <url>/posts/590352ba/</url>
    <content><![CDATA[<p>本篇文章主要记录git branch常用操作</p>
<a id="more"></a>

<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [&lt;branchname&gt;]    //创建分支</span><br><span class="line">git checkout [&lt;branchname&gt;]    //切换分支</span><br><span class="line">git checkout -b [&lt;branchname&gt;]    //创建并切换分支</span><br></pre></td></tr></table></figure>

<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d [&lt;branchname&gt;]    //删除本地分支（本地分支和远程分支完全merge）</span><br><span class="line">git branch -D [&lt;branchname&gt;]    //强制删除本地分支</span><br><span class="line">git push origin --delete [&lt;branchname&gt;]    //删除远程分支</span><br></pre></td></tr></table></figure>

<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch //查看本地分支</span><br><span class="line">git branch -a //查看所有分支（本地+远程）</span><br></pre></td></tr></table></figure>

<h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><h3 id="本地分支重命名-还没有推送到远程"><a href="#本地分支重命名-还没有推送到远程" class="headerlink" title="本地分支重命名(还没有推送到远程)"></a>本地分支重命名(还没有推送到远程)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="远程分支重命名-已经推送远程"><a href="#远程分支重命名-已经推送远程" class="headerlink" title="远程分支重命名 (已经推送远程)"></a>远程分支重命名 (已经推送远程)</h3><ol>
<li><p>重命名远程分支对应的本地分支</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程分支</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin [&lt;oldbranch&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传新命名的本地分支</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把修改后的本地分支与远程分支关联</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newbranch</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="描述分支"><a href="#描述分支" class="headerlink" title="描述分支"></a>描述分支</h2><h3 id="添加描述"><a href="#添加描述" class="headerlink" title="添加描述"></a>添加描述</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --edit-description [&lt;description&gt;]    //给本地分支添加描述</span><br><span class="line">git config branch.<span class="variable">$&#123;branchname&#125;</span>.description [&lt;description&gt;]    //给指定分支添加描述</span><br></pre></td></tr></table></figure>

<h3 id="查看描述"><a href="#查看描述" class="headerlink" title="查看描述"></a>查看描述</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config branch.<span class="variable">$&#123;branchname&#125;</span>.description    //查看指定分支描述</span><br></pre></td></tr></table></figure>

<h3 id="使用git-br查看本地分支描述"><a href="#使用git-br查看本地分支描述" class="headerlink" title="使用git-br查看本地分支描述"></a>使用git-br查看本地分支描述</h3><ol>
<li><p>安装</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install git-br -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置别名</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.br !git-br</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地分支</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git br</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/590352ba/">https://blooddot.cool/posts/590352ba/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Typescript 实现单例模式</title>
    <url>/posts/d3b10281/</url>
    <content><![CDATA[<p>本篇文章主要介绍使用 Typescript 实现「单例模式」
 <a id="more"></a> </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。<br>在应用这个模式时，单例对象的类必须保证只有一个实例存在。<br>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>延迟初始化。我们不需要在整个游戏周期开始前创建实例，而是在第一次使用时创建。因此，这样实现的单例可以节省 CPU 周期和内存使用。</li>
<li>获取初始化后的数据。当游戏初始化完毕后，再调用单例，就可以在单例初始化的时候，获取到我们游戏初始化的数据，这样就可以更好的控制游戏的行为。</li>
<li>可继承的单例。单例模式可以继承，这样就可以在单例子类中添加新的方法，而不会影响到父类的单例。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>全局可访问。由于单例都是全局变量，如果大量的代码使用了这个单例，而其中一个出了问题，我们必须从数百个引用中去寻找出错的那个。</li>
<li>增加耦合。如果我们的单例类和其他类之间有很多依赖关系，那么这些类会变得庞大。</li>
<li>创建实例的限制。由于单例模式的特点，我们只能创建一个单例实例，而不能创建多个实例。这就导致当要扩展单例时，我们只能在单例类中添加新的方法，而不能使用多个实例来扩展单例。</li>
<li>延迟初始化的副作用。当在第一次使用时初始化单例，如果当前 CPU 和内存占用较高，单例初始化可能会导致游戏卡顿。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><ul>
<li>尽可能少的使用单例</li>
<li>限制全局访问。确保只有一个实例，但它不能被外部访问。这就解决了那些 “多实例” 所带来的问题，同时又不暴露全局入口来削弱整体的框架。</li>
<li>使用 “服务定位器”。简而言之，将这些 “杂类” 比如说 “日志系统”、“存档系统” 之类的类改为 “非单例模式”，之后将他们存储在一个全局对象中，以便其他类通过 “全局对象-&gt;子系统” 来调用。这将有效地减少对单实例的使用。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><pre><code>无论你是否使用，在类加载的时候就初始化了，所以会占据空间，浪费内存。
</code></pre>
<h4 id="饿汉式-导出实例"><a href="#饿汉式-导出实例" class="headerlink" title="饿汉式-导出实例"></a>饿汉式-导出实例</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">singleton.print();  <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<h4 id="饿汉式-静态类"><a href="#饿汉式-静态类" class="headerlink" title="饿汉式-静态类"></a>饿汉式-静态类</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.print(); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<h4 id="饿汉式-静态属性"><a href="#饿汉式-静态属性" class="headerlink" title="饿汉式-静态属性"></a>饿汉式-静态属性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _instance: Singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance(): Singleton &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance().print(); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><pre><code>在需要的时候进行实例化，相对来说不浪费内存。
</code></pre>
<h4 id="懒汉式-静态属性"><a href="#懒汉式-静态属性" class="headerlink" title="懒汉式-静态属性"></a>懒汉式-静态属性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _instance: Singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance(): Singleton &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Singleton._instance) &#123;</span><br><span class="line">            Singleton._instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance().print(); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<h4 id="懒汉式-静态-getter-属性"><a href="#懒汉式-静态-getter-属性" class="headerlink" title="懒汉式-静态 getter 属性"></a>懒汉式-静态 getter 属性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _instance: Singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">instance</span>(): <span class="title">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Singleton._instance) &#123;</span><br><span class="line">            Singleton._instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.instance.print(); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<h2 id="可继承的单例"><a href="#可继承的单例" class="headerlink" title="可继承的单例"></a>可继承的单例</h2><p>如果经常写单例，可以发现以上这些实现方式，都无法让单例类可以被继承。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _instance: SingletonA;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance(): SingletonA &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SingletonA._instance) &#123;</span><br><span class="line">            SingletonA._instance = <span class="keyword">new</span> SingletonA();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SingletonA._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonA!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonB</span> <span class="keyword">extends</span> <span class="title">SingletonA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonB!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingletonB.getInstance().print(); <span class="comment">// this is SingletonA!</span></span><br><span class="line"><span class="built_in">console</span>.log(SingletonB.getInstance() <span class="keyword">instanceof</span> SingletonA); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SingletonB.getInstance() <span class="keyword">instanceof</span> SingletonB); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如上例所示，在 SingletonB 继承 SingletonA 后，通过 getInstance 静态方法获取到的并非 SingletonB 的实例，而是 SingletonA 的实例，并且调用的 print 方法也是没有复写的。</p>
<p>那么有没有什么方法可以实现单例的继承呢，那就要用到 Typescript 的范型功能了。<br>可以看到在 getInstance 静态方法我们创建和返回的是指定的 SingletonA 类型，如果通过范型将类的定义穿参进去，指定我们要创建和返回的类型，那就实现我们要的继承单例了。<br>以下是示例代码：  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> _instance: SingletonA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance&lt;T <span class="keyword">extends</span> <span class="keyword">typeof</span> SingletonA&gt;(<span class="built_in">this</span>: T): InstanceType&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._instance) &#123;</span><br><span class="line">            <span class="built_in">this</span>._instance = <span class="keyword">new</span> <span class="built_in">this</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._instance <span class="keyword">as</span> InstanceType&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonA!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonB</span> <span class="keyword">extends</span> <span class="title">SingletonA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonB!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingletonB.getInstance().print(); <span class="comment">// this is SingletonB!</span></span><br><span class="line"><span class="built_in">console</span>.log(SingletonB.getInstance() <span class="keyword">instanceof</span> SingletonA); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SingletonB.getInstance() <span class="keyword">instanceof</span> SingletonB); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>细心的朋友可能注意到，我们现在使用 getInstance 静态方法，通过传入范型对象的方式，将当前类定义初始化为实例。<br>那么是否可以使用静态 getter 属性实现单例的继承呢？<br>经过尝试，我们发现静态 getter 属性并不能传递参数，这意味着我们不能直接向静态 getter 属性添加范型参数实例化。  </p>
<p>范型对象是通过方法进行传参的，那么我们如果能够通过方法进行类的定义化，是不是就能够进行单例的继承了呢？
我们尝试过后发现，通过方法返回类定义的话，是可以实现继承的！
以下是示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">SingletonA</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> _instance: unknown = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">instance</span>(): <span class="title">T</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (C._instance === <span class="literal">null</span>) &#123;</span><br><span class="line">                C._instance = <span class="keyword">new</span> <span class="built_in">this</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> C._instance <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonA!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">SingletonB</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SingletonA</span>&lt;<span class="title">C</span> &amp; <span class="title">T</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;this is SingletonB!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseManager</span> <span class="keyword">extends</span> <span class="title">SingletonB</span>&lt;<span class="title">BaseManager</span>&gt;()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">BaseManager.instance.print(); <span class="comment">// this is SingletonB!</span></span><br><span class="line"><span class="built_in">console</span>.log(BaseManager.instance <span class="keyword">instanceof</span> BaseManager); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">wiki 单例模式</a></li>
<li><a href="https://gpp.tkchu.me/singleton.html">单例模式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/488870511">【游戏编程模式】单例模式</a></li>
</ul>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/d3b10281/">https://blooddot.cool/posts/d3b10281/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单对象池管理器实现</title>
    <url>/posts/9c88a4d3/</url>
    <content><![CDATA[<p>本篇文章主要介绍一下「对象池管理器」的实现思路和步骤
 <a id="more"></a> </p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在处理游戏的视觉表现上，当有许多视图重复的绘制和移除时，系统需要频繁的进行创建和销毁，造成压力。<br>
另一方面，如果创建和销毁没有进行很好的管理，很可能出现内存泄漏的情况。</p>
<p>例如三消游戏，游戏场景有许多消除元素，当重复消除元素时，会将消除的元素进行销毁，再将新的元素创建并添加到舞台上。如果频繁的消除，这个过程将进行非常多次。</p>
<p>鱼与熊掌不可兼得，但「对象池模式」的出现，却能够在减少创建和销毁压力的同时，又能很好的管理内存。</p>
<h2 id="WIKI-对象池模式的定义"><a href="#WIKI-对象池模式的定义" class="headerlink" title="WIKI 对象池模式的定义"></a>WIKI 对象池模式的定义</h2><blockquote>
<p>对象池（英语：object pool pattern）是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。 </p>
</blockquote>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>提供一个通用的对象池管理器，来管理所有池子数据，在提供外部方法用于获取和释放对象到池子内，并调用对象的初始化和释放的方法。<br>
目标对象需要实现指定的对象池对象接口，用于初始化和释放。<br></p>
<h2 id="术语与缩略语"><a href="#术语与缩略语" class="headerlink" title="术语与缩略语"></a>术语与缩略语</h2><p>| name | meaning | description |
| —- | ——- | ———– |
| <code>PoolMgr</code> | 对象池管理器 | 用于创建和回收对象, 管理对象池 |
| <code>IPoolData</code> | 池子接口 | 用于存储对象池对象的数据实现的接口，以下简称池子 |
| <code>IPoolObject</code> | 对象池对象接口 | 对象池内对象需要实现的接口 |</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li><p><strong>获取对象</strong><br>
当需要创建新对象时，从管理器要一个，查找是否存在指定池子对象。<br>
当不存在池子或者池子数量小于等于 0 时，创建一个对象并返回。<br>
否则，从池子中拿出一个对象。<br>
取出的对象会执行 <code>onAcquire</code> 方法进行初始化。<br></p>
</li>
<li><p><strong>释放对象</strong><br>
当对象不需要时，将对象放回到池子中，查找是否存在指定池子对象。<br>
当不存在池子时，创建一个池子对象。<br>
否则，获取该池子对象。<br>
将对象放回到池子中，放回的对象会执行 <code>onRelease</code> 方法进行回收。<br></p>
</li>
<li><p><strong>设置池子上限</strong><br>
调用管理器的 <code>setMaxPoolSize</code> 方法设置指定池子的数量上限。<br>
当不存在池子时，会自动创建一个。<br></p>
</li>
<li><p><strong>清除池子</strong><br>
调用管理器的 <code>clear</code> 方法可以清除制定池子的数据。<br></p>
</li>
</ul>
<h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="PoolMgr-对象池管理器"><a href="#PoolMgr-对象池管理器" class="headerlink" title="PoolMgr 对象池管理器"></a>PoolMgr 对象池管理器</h4><blockquote>
<p>通过创建一个全局的单例，用来管理对象及池子的创建和回收</p>
</blockquote>
<p>方法一览：</p>
<ul>
<li><strong>acquire</strong> 取出一个对象池对象（如果不存在该对象的池子，或者池子内不存在数据，则创建一个新的对象。）</li>
<li><strong>release</strong> 释放一个对象回池子中（如果不存在该对象的池子，则创建一个新的池子。如果设置了池子对象数量上限，则超出数量后不回收到池子内）</li>
<li><strong>setMaxPoolSize</strong> 设置指定池子最大对象数量</li>
<li><strong>clear</strong> 清除指定池子数据</li>
</ul>
<h4 id="IPoolData-池子接口"><a href="#IPoolData-池子接口" class="headerlink" title="IPoolData 池子接口"></a>IPoolData 池子接口</h4><blockquote>
<p>通过存储对象池对象的数据集合接口</p>
</blockquote>
<p>方法一览：</p>
<ul>
<li><strong>poolObjects</strong> 对象池对象数据</li>
<li><strong>maxPoolSize</strong> 当前池子对象数量上限</li>
</ul>
<h4 id="IPoolObject-对象池对象接口"><a href="#IPoolObject-对象池对象接口" class="headerlink" title="IPoolObject 对象池对象接口"></a>IPoolObject 对象池对象接口</h4><blockquote>
<p>对象池内对象需要实现的接口</p>
</blockquote>
<p>方法一览：</p>
<ul>
<li><strong>poolKey</strong> 对应的池子 key，用于回收时查找池子</li>
<li><strong>onAcquire</strong> 当从池子取出时，初始化方法</li>
<li><strong>onRelease</strong> 当释放回池子时，回收的方法</li>
</ul>
<h3 id="UML-类图结构"><a href="#UML-类图结构" class="headerlink" title="UML 类图结构"></a>UML 类图结构</h3><p><img src="https://raw.githubusercontent.com/blooddot/figure-bed/master/blog/20210917153707.png" alt="20210917153707"></p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="从池子中取出对象"><a href="#从池子中取出对象" class="headerlink" title="从池子中取出对象"></a>从池子中取出对象</h4><p><img src="https://raw.githubusercontent.com/blooddot/figure-bed/master/blog/20210917153132.png" alt="20210917153132"></p>
<h4 id="将对象释放回池子"><a href="#将对象释放回池子" class="headerlink" title="将对象释放回池子"></a>将对象释放回池子</h4><p><img src="https://raw.githubusercontent.com/blooddot/figure-bed/master/blog/20210917153242.png" alt="20210917153242"></p>
<h2 id="架构的取舍"><a href="#架构的取舍" class="headerlink" title="架构的取舍"></a>架构的取舍</h2><ul>
<li><p>对象池对象没有使用继承的方式实现，而是采用接口的方式。<br>
优点是可以做到通用性，不依赖当前框架的数据结构，跨框架的使用，复用性和移植性强。<br>
缺点是没有通用的父类方法，对于初始化和释放都要自己实现。<br></p>
</li>
<li><p>为了更好的扩展性，并没有针对池子上限进行限制，也没有自动释放对象池的机制，需要使用者自行管理。</p>
</li>
<li><p>由于池子存储的 <code>key</code> 依赖于对象本身的类名，当进行代码混淆的时候，会出现类名重复的情况，从而导致池子重复，出现异常。<br>
解决方案是对象池对象实现一个静态属性 <code>className</code> , 用于生成池子 <code>key</code> 。并且通过在对象池获取和释放对象时，传入的构造类型参数中添加静态属性 <code>className</code> 的检测。<br></p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>这个模式广泛应用于可见的事物上，比如游戏实体和视觉效果。<br>
但是它也可在不那么视觉化的数据结构上使用，比如正在播放的声音。<br>
在以下情况中使用对象池：</p>
<ul>
<li>需要频繁创建和销毁对象。</li>
<li>数量受限的资源。</li>
<li>创建成本高昂的对象。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p><strong>清除池子的时机</strong><br>
池子可能在不需要的对象上浪费内存，所以使用时，如果发现后续场景不会从池子中获取对象，请主动清除。</p>
</li>
<li><p><strong>池子上限</strong><br>
默认并未设置池子上限，需要使用者根据游戏的需求设置。当池子太小时，很明显需要调整。但是也要小心确保池子没有太大。</p>
</li>
<li><p><strong>对象池对象的释放</strong><br/>
请确保对象池对象在释放的时候，除了池子以外，没有其他地方对其的引用，也没有监听事件或者保持对全局对象的引用。<br>
不然就算清除了池子，对象池对象也不会在内存中释放，反而会造成内存泄漏。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://gpp.tkchu.me/object-pool.html">对象池模式</a><br>
<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">WIKI</a><br>
<a href="https://android.googlesource.com/platform/frameworks/support/+/1fcce44/v4/java/android/support/v4/util/Pools.java">Android Pools 源码</a><br></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/9c88a4d3/">https://blooddot.cool/posts/9c88a4d3/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-数组</title>
    <url>/posts/b702bc87/</url>
    <content><![CDATA[<p>leetcode 中数组相关的题型</p>
<a id="more"></a>

<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><blockquote>
<p>数组是存放在连续内存空间上的相同类型数据的集合。</p>
</blockquote>
<p><img src="../../images/leetcode/leetcode-array-1.jpg" alt="leetcode-array-1"></p>
<ul>
<li>数组下标都是从0开始的。</li>
<li>数组内存空间的地址是连续的</li>
</ul>
<p>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</p>
<p><img src="../../images/leetcode/leetcode-array-2.png" alt="leetcode-array-2"></p>
<p>数组的元素是不能删的，只能覆盖。</p>
<h3 id="二维数组结构"><a href="#二维数组结构" class="headerlink" title="二维数组结构"></a>二维数组结构</h3><p><img src="../../images/leetcode/leetcode-array-3.png" alt="leetcode-array-3"></p>
<p>那么二维数组在内存的空间地址是连续的么？</p>
<p>不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。</p>
<p>我们来做一个实验，C++测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试地址为</p>
<p>0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>
<p>0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。</p>
<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。</p>
<p><img src="../../images/leetcode/leetcode-array-5.png" alt="leetcode-array-5"></p>
<p>Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p>
<p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的地址为：</p>
<p>[I@7852e922<br>[I@4e25154f<br>[I@70dea4e<br>[I@5c647e05</p>
<p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p>
<p><img src="../../images/leetcode/leetcode-array-4.png" alt="leetcode-array-4"></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">二分查找</a></h2><blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [-1, 0, 3, 5, 9, 12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [-1, 0, 3, 5, 9, 12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p>提示：  </p>
<ul>
<li>你可以假设 nums 中的所有元素是不重复的。</li>
<li>n 将在 [1, 10000]之间。</li>
<li>nums 的每个元素都将在 [-9999, 9999]之间。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分法前提条件</p>
<ul>
<li>有序数组</li>
<li>数组中无重复元素</li>
</ul>
<blockquote>
<p>循环不变量规则: 在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。</p>
</blockquote>
<h4 id="左闭右闭即-left-right"><a href="#左闭右闭即-left-right" class="headerlink" title="左闭右闭即[left, right]"></a>左闭右闭即[left, right]</h4><ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>例如在数组：1, 2, 3, 4, 7, 9, 10中查找元素2，如图所示：</p>
<p><img src="../../images/leetcode/leetcode-array-6.jpg" alt="leetcode-array-6"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> middle: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right: <span class="built_in">number</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 位运算 + 防止大数溢出</span></span><br><span class="line">        middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="左闭右开即-left-right"><a href="#左闭右开即-left-right" class="headerlink" title="左闭右开即[left, right)"></a>左闭右开即[left, right)</h4><ul>
<li>while (left &lt; right)，这里使用 &lt; , 因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> middle: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right: <span class="built_in">number</span> = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 位运算 + 防止大数溢出</span></span><br><span class="line">        middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a><br><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a><br><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a><br><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></p>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">移除元素</a></h2><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong>原地</strong> 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, </span><br><span class="line">函数应该返回新的长度 2, </span><br><span class="line">并且 nums 中的前两个元素均为 2。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line">函数应该返回新的长度 5,</span><br><span class="line">并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p>
<p><img src="../../images/leetcode/leetcode-array-7.gif" alt="leetcode-array-7"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeElement</span>(<span class="params">nums:<span class="built_in">number</span>[], val:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> size = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">            size--; <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> size;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src="../../images/leetcode/leetcode-array-8.gif" alt="leetcode-array-8"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeElement</span>(<span class="params">nums: <span class="built_in">number</span>[], val: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slowIndex: <span class="built_in">number</span> = <span class="number">0</span>, <span class="attr">fastIndex</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fastIndex &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fastIndex] !== val) &#123;</span><br><span class="line">            nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目推荐-1"><a href="#相关题目推荐-1" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a><br><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a><br><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a><br><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h2><blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：s &#x3D; 7, nums &#x3D; [2, 3, 1, 2, 4, 3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4, 3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>两个for循环，然后不断的寻找符合条件的子序列。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minSubArrayLen</span>(<span class="params">target: <span class="built_in">number</span>, nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">    <span class="keyword">let</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int j = i; j &lt; nums.size(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                result = result &lt; subLength ? result : subLength;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)
空间复杂度：O(1)</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><blockquote>
<p>不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p>
</blockquote>
<p>首先要思考 如果用一个 for 循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个 for 循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个 for 循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。</p>
<p>那么问题来了，滑动窗口的起始位置如何移动呢？</p>
<p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p><img src="../../images/leetcode/leetcode-array-10.gif" alt="leetcode-array-10"></p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口定义：满足其和 ≥ s 的长度最小的 连续 子数组。</li>
<li>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</li>
<li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li>
</ul>
<p><img src="../../images/leetcode/leetcode-array-11.png" alt="leetcode-array-11"></p>
<p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minSubArrayLen</span>(<span class="params">target: <span class="built_in">number</span>, nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            result = <span class="built_in">Math</span>.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">return</span> result === <span class="built_in">Number</span>.MAX_SAFE_INTEGER ? <span class="number">0</span> : result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)
空间复杂度：O(1)</p>
<h3 id="相关题目推荐-2"><a href="#相关题目推荐-2" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>
<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></p>
<h2 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title=" 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/"> 螺旋矩阵 II</a></h2><blockquote>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
</blockquote>
<p><img src="../../images/leetcode/leetcode-array-12.png" alt="leetcode-array-12"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上
由外向内一圈一圈这么画下去，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则。</li>
</ul>
<p>左闭右开的原则画法：</p>
<p><img src="../../images/leetcode/leetcode-array-14.png" alt="leetcode-array-14"></p>
<p>这里每一种颜色，代表一条边，每一个拐角处让给新的一条边来继续画。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateMatrix</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> loopNum: <span class="built_in">number</span> = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> resArr: <span class="built_in">number</span>[][] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>).map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n));</span><br><span class="line">    <span class="keyword">let</span> chunkNum: <span class="built_in">number</span> = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> startX: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> startY: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">while</span> (loopNum--) &#123;</span><br><span class="line">        x = startX;</span><br><span class="line">        y = startY;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; startX + chunkNum) &#123;</span><br><span class="line">            resArr[y][x] = value;</span><br><span class="line">            x++;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y &lt; startY + chunkNum) &#123;</span><br><span class="line">            resArr[y][x] = value;</span><br><span class="line">            y++;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; startX) &#123;</span><br><span class="line">            resArr[y][x] = value;</span><br><span class="line">            x--;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y &gt; startY) &#123;</span><br><span class="line">            resArr[y][x] = value;</span><br><span class="line">            y--;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line">        chunkNum -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        resArr[startX][startY] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目推荐-3"><a href="#相关题目推荐-3" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a><br><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../images/leetcode/leetcode-array-14.png" alt="leetcode-array-14"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md">数组理论基础</a><br><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">二分查找</a><br><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.md">移除元素</a><br><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md">长度最小的子数组</a><br><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.md">螺旋矩阵II</a><br><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.md">数组总结篇</a></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/b702bc87/">https://blooddot.cool/posts/b702bc87/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 2D 乓乓游戏（一）</title>
    <url>/posts/1d1dd166/</url>
    <content><![CDATA[<p>【非原创2D游戏教程】乓乓游戏
<a href="https://blooddot.cool/posts/dbdef186/">教程目录地址</a></p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702094615.png" alt="20210702094615"></p>
<p>这是一个只用38行代码就能够做出2d乒乓游戏的教程哟~ 当然，肯定是用unity游戏引擎来做的，安心啦，会一步步教的。<br>给你个gif图，自己看游戏最终效果</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702214949.gif" alt="20210702214949"></p>
<hr>
<p>一点用都没有的前言<br>这个游戏灵感来源于1972年的原始乒乓游戏（tm不就是抄的一样么），中文介绍只找到了互动百科，将就着看看咯（<a href="https://baike.baidu.com/item/pong/22463728?fr=aladdin">https://baike.baidu.com/item/pong/22463728?fr=aladdin</a>） (已更新百度百科)<br>先来讨论一下游戏的规则，顺便再学习♂一下Unity的基本知识&lt;(￣︶￣)/<br>就叫游戏的说明好了</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702094734.png" alt="20210702094734"></p>
<p>游戏规则会和原本的非常相（yi）像（yang），像控制左边和右边的挡板让球弹来弹去，弹到左边的墙，右边的人得分啦，反过来球弹到右边的墙，左边的人得分啦，但是球打到上下的墙肯定不会得分的，只会让球上下弹来弹去，然后弹到左右咯。所以要控制左右的板子接住球并回弹就哦了。其实这些都好废话，又不是zz，看gif图都懂的好伐。<br>来看一下这个球打到板子上的回弹角度设定：</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702094801.png" alt="20210702094801"></p>
<p>如果球打到顶部的边角，就是那个绿色箭头，那么往上弹<br>达到中间，看红色箭头，往回弹<br>达到下面，蓝色箭头，自己看<br>规则扯完了，其实不讲大家也都知道规则的，只是强迫症要把这段弄一弄</p>
<hr>
<p>开始讲Unity相关的东西咯<br>为了做游戏，快用unity，学好unity，走遍天下都有利。<br>首先，自己百度unity去下载和安装，不会装的，那怪我咯(๑<em>•̀ω•́)</em></p>
<p>关于unity的简介，我就借（chao）鉴（xi）一下百度百科了  </p>
<blockquote>
<p>Unity3D是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。Unity类似于Director,Blender game engine, Virtools 或 Torque Game Builder等利用交互的图型化开发环境为首要方式的软件。其编辑器运行在Windows 和Mac OS X下，可发布游戏至Windows、Mac、Wii、iPhone、WebGL（需要HTML5）、Windows phone 8和Android平台。也可以利用Unity web player插件发布网页游戏，支持Mac和Windows的网页浏览。它的网页播放器也被Mac widgets所支持。</p>
</blockquote>
<p>顺便吐槽一下，百度百科中文翻译Unity3d竟然叫优美缔3D，瞎了<br>再说一下，Unity虽然做游戏很方便，但是还是要写代码的，可以用C#，Javascript和Boo三种语言来写，选C#吧，微软大法好啊，虽然我因为大学时的C#老师太丑，这些年对C#都很嫌弃，但说实话，C#用起来的确很爽</p>
<hr>
<p>装完了Unity没，装完了就赶紧来开启Unity的学习之路吧</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702095337.png" alt="20210702095337"></p>
<p>激活你的Unity啦，选个人版，不要钱的，当然你有钱你随意<br>不过5.0以前的Unity是要收钱的，但天朝一般都用破解版</p>
<p>然后你自己注册或登录一下Unity的个人账号就可以进入到以下界面了，不知道怎么注册的，出门左转，问一下路人怎么用浏览器打开百度输入注册Unity账号<br>看图，选下面的New Project，差不多就是新创建一个项目的意思</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702095422.png" alt="20210702095422"></p>
<p>然后取名字，按照官方的来吧，叫pong<br>自己选项目的路径，最后记得选择2D项目<br>点击Create project创建项目</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702095904.png" alt="20210702095904"></p>
<p>接下去泡一下泡面，等它loading完吧</p>
<hr>
<p>介绍一下Unity基本的操作界面啦看下面(￣y▽￣)╭</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702095904.png" alt="20210702095904"></p>
<p>Hierarchy（层级视图）：Hierarchy视图是主要放于游戏场景中具体的游戏对象，比如摄像机平面贴图、3D贴图、光源、箱子、球体、胶囊体、平面和地形等。任何一个全新的的游戏工程创建完毕后，默认都会创建一个游戏场景并且将主摄像机添加在该场景的Hierarchy视图中。对于3D游戏来说。摄像机可以让我们以不同的视角观察游戏世界。<br>上面的是百度百科的，我不是安利百度百科，只是我没翻墙</p>
<p>Project Area（项目区域）：其实就是放我们游戏素材的地方，像Textures（贴图）啦，3D Models（3D模型）啦，Scripts（脚本代码）啦，等等。我们可以直接把这里的素材拖拽到层级视图上面实例化（不过代码不应该叫绑定，不叫实例）</p>
<p>Scene（场景）：就是显示我们游戏的地方，可以用鼠标拖拽或者用键盘控制场景的上下左右移动，也可以在层级视图双击里面的摄像头或者其他的对象定位到双击的目标</p>
<p>Inspector（检视视图）：显示当前选择对象的属性。举个栗子，当我们选择Main Camera（主摄像头）的时候，我们能够看到Position（位置），Rotation（旋转角度），Name（名称）等等全部关于摄像头的全部信息</p>
<p>对于Unity这种组件式的游戏引擎来讲，刚创建的对象什么都没有（包括头发），我们要自己给场景里面添加组件。像Light（光效），Position（位置），Texture（贴图），3D Model（3D模型）等等。我们点击默认创建的Main Camera，可以从Inspector（检视视图）上看到它绑定的初始组件，Transform，Camera，GUI Layer，Flare Layer，Audio Listener。具体干什么用的，等之后用到了再讲吧。简单来说Unity的这种结构就有点像拼机器人，Main Camera就类似机器人的头，头里面有眼睛，耳朵，鼻子，嘴巴等等（这些就类似于刚才绑定在Main Camera上面的组件），把这些组件组合起来就是一个物体，然后游戏是由很多个物体组成的，就和机器人是由头，手，胸，脚等等组合起来的差不多（Main Camera：我来组成头部）</p>
<p>变换工具（上图中的左上角，具体看下图）：</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702100051.png" alt="20210702100051"></p>
<p>从左到右依次是<br>手型工具（快捷键Q）：按住鼠标左键拖动视角<br>移动工具（快捷键W）：选择物体后，物体会出现方向轴，拖动方向轴可以移动物体<br>旋转工具（快捷键E）：选择物体后，物体会出现旋转轴，拖动旋转轴可以旋转物体<br>缩放工具（快捷键R）：选择物体后，物体会出现缩放轴，拖动缩放轴可以缩放物体<br>我反正没用快捷键，不过用多了撸啊撸放技能速度应该能提升吧（笑）  </p>
<p>播放暂停步进工具条：</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702100159.png" alt="20210702100159"></p>
<p>从左到右依次是<br>播放：开始游戏，点击以后开始调试游戏，并且该按钮变成停止按钮，点击停止按钮来停止调试游戏<br>暂停：当在调试游戏的时候，可以暂停游戏，修改一些数据，资源，脚本等来查看修改后的表现，不过在停止播放后，暂停游戏中修改的东西就会还原回播放之前的状态哦<br>步进：前进到下一帧，关于帧频这个东西，如果不知道的话，可以自行百度以上是Unity编辑器的简单介绍，下面要进入游戏主体教程了哟吼吼吼吼</p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/1d1dd166/">https://blooddot.cool/posts/1d1dd166/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 2D 乓乓游戏（三）</title>
    <url>/posts/60159eec/</url>
    <content><![CDATA[<p>【非原创2D游戏教程】乓乓游戏
<a href="https://blooddot.cool/posts/dbdef186/">教程目录地址</a></p>
<a id="more"></a>

<p>给墙壁加上物理属性（让它能够和之后的小球基情的撞击）<br>怎么加呢，不用担心啦，Unity就是因为它神奇的物理引擎而出名的，我们只要使用Unity提供的Collider组件就可以给墙壁添加物理碰撞属性啦，让我们先选中四个墙壁</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702205833.png" alt="20210702205833"></p>
<p>然后我们在右边的Inspector（检视）面板点击Add Component（添加组件），然后依次选择Physics2D-&gt;Box Collider2D</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702205855.png" alt="20210702205855"></p>
<p>不用改参数哦，Unity就是这么智能，默认把碰撞框的大小设置成图片大小</p>
<p>然后来Scene（场景）里面看看吧，每个墙壁是不是都有绿色边框围绕啊，那就是碰撞框</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702205955.png" alt="20210702205955"></p>
<p>我们再来添加一下中间的虚线</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702210258.png" alt="20210702210258"></p>
<p>放心老哥，你没瞎，选中下载虚线</p>
<p>老规矩，设置一下Pixels Per Unit为1</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702210334.png" alt="20210702210334"></p>
<p>调整一下中间虚线的位置，和下图差不多就行了，虚线就不用添加物理组件了，它只是用来装饰的玩意</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702210358.png" alt="20210702210358"></p>
<p>轮到球拍登场了快下图</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702210754.png" alt="20210702210754"></p>
<p>选中下载图片吧~<br>也是把Pixels Per Unit设置为1，这我就懒得贴图了<br>拖两个球拍的图片放到一左一右，作为我们控制的两个玩家，强迫症记得对其哟~</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702210538.png" alt="20210702210538"></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/60159eec/">https://blooddot.cool/posts/60159eec/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 2D 乓乓游戏（二）</title>
    <url>/posts/2d0b3dbe/</url>
    <content><![CDATA[<p>【非原创2D游戏教程】乓乓游戏
<a href="https://blooddot.cool/posts/dbdef186/">教程目录地址</a></p>
<a id="more"></a>

<p>来设置一下摄像头先吧<br>我们在Hierarchy（层级）面板中选择Main Camera，如下图</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702114640.png" alt="20210702114640"></p>
<p>然后我们把目光焦点放到右侧的Inspector（检视）面板，将Background（背景）颜色改成黑色，设置图中的Size等等参数（你照着图中抄就好了）</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702114712.png" alt="20210702114712"></p>
<hr>
<p>开始创建上下左右的墙壁了~<br>我们要添加四面墙壁到游戏里面，在游戏里面这些墙壁的对象叫做Sprite（精灵），为什么叫这个英文名和中文翻译名，鬼才知道，或者我们也可以叫另一个稍微明白点的名字Texture（贴图）<br>快把下面的图片下载下来</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/3940f603918fa0ec622c309a2f9759ee3f6ddbca.png" alt="3940f603918fa0ec622c309a2f9759ee3f6ddbca"></p>
<p>你眼睛没有瞎，上面图片是白的，你选中看看就知道了<br>把上面的图片放到项目的Assets文件夹里，我习惯在Assets里创建一个Sprites文件夹，把图片资源放在这个文件夹里面<br>如下图所示</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702115315.png" alt="20210702115315"></p>
<p>Materials文件夹：用于存放Unity里面创建的Material<br>Prefabs文件夹：用于存放Unity里面创建的Prefab，预制体（暂时听不懂没关系）
Scenes文件夹：用于存放Unity里面创建的Scene，场景其实就是游戏场景，你可以保存一下当前的项目，保存的后缀名是.unity文件，这个其实就是当前的Unity场景，我们保存到Scenes文件夹里面<br>Scripts文件夹：用于存放Unity里面创建的Script，也就是代码<br>Sprites文件夹：用于存放图片素材  </p>
<hr>
<p>创建游戏里面用到的墙壁吧我们选择Sprites文件夹，选中里面的两个墙壁图片，然后将Inspector（检视）面板中的属性设置为下图</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702115412.png" alt="20210702115412"></p>
<p>其实就只要设置Pixels Per Unit这个参数为1啦，这个参数是干嘛用的呢，从字面意思看是像素每单位，其实差不多就是这个意思了，就是多少单位占1个像素的意思，当我们设置为1的时候，那么墙壁的就是1个单位对应1个像素了（其实一般游戏框架里面都是默认这样，并没有这个参数可以设置的）</p>
<p>把刚才的墙壁加入到游戏场景中先在Sprites文件夹里选中一个竖着的墙，然后拖拽到Scene（场景）面板中，如下图</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702115412.png" alt="20210702115412"></p>
<p>然后再拖两根横着的墙和一根竖着的墙，强迫症患者赶快对齐这四根棒子</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702115708.png" alt="20210702115708"></p>
<p>用鼠标拖肯定对不齐的，在左边的Hierarchy（层级）面板一根选中墙壁，然后在右边的Inspector（检视）面板输入坐标来对齐吧</p>
<p>记得把墙壁重命名啊</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702115738.png" alt="20210702115738"></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/2d0b3dbe/">https://blooddot.cool/posts/2d0b3dbe/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 2D 乓乓游戏（五）</title>
    <url>/posts/b8a642ce/</url>
    <content><![CDATA[<p>【非原创2D游戏教程】乓乓游戏
<a href="https://blooddot.cool/posts/dbdef186/">教程目录地址</a></p>
<a id="more"></a>

<p>做个球<br>先把下面这个球的图片下载一下</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212829.png" alt="20210702212829"></p>
<p>然后设置一下我们刚才导入的图片</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212855.png" alt="20210702212855"></p>
<p>把球的图片拖到场景里面来吧，看下面</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212915.png" alt="20210702212915"></p>
<p>给球添加一下Collider（碰撞器）组件<br>Add Component-&gt;Physics 2D-&gt;Box Collider 2D</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212934.png" alt="20210702212934"></p>
<p>我们的球是要在碰到墙的时候回弹回来的，举个栗子，当面对面碰到墙的时候，是直接回弹回来，当以45度朝着墙碰的时候，它会以-45度回弹回来</p>
<p>听起来有些复杂，涉及到了数学相关的知识，但Unity关于这方面提供了很完善的支持，用它自带的Physics Material，就能够实现回弹的效果，不用管其他杂七杂八的事情</p>
<p>让我们来创建一个Physics2D Material吧<br>在Project Area（项目区域）里面一次选择Create-&gt;Physics2D Material，然后命名为BallMaterial<br>在Inspector（检视）面板里面设置一下</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213010.png" alt="20210702213010"></p>
<p>可以看到我们将Friction（摩擦力）设置为0 Bounciness（反弹力）设置为1</p>
<p>然后在球的Collider的Material设置一下刚才创建的Material</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213036.png" alt="20210702213036"></p>
<p>给球添加一下Rigidbody<br>Add Component-&gt;Physics 2D-&gt;Rigidbody 2D<br>然后设置一下参数，像下面这样子</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213056.png" alt="20210702213056"></p>
<p>好了，我们再来给球添加一个脚本，让它动起来吧<br>Add Component-&gt;New Script，并命名为Ball
看下面的代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Ball</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Initial Velocity</span></span><br><span class="line">        GetComponent&lt;Rigidbody2D&gt;().velocity = Vector2.right * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再加一个speed的变量，用来控制球速，并在初始化的时候，给球一个向右的速度，让它动起来<br>点击调试，可以看到球在两个球拍之间回弹</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213307.gif" alt="20210702213307"></p>
<p>好了，直线的回弹已经有效果了，斜着的回弹我们要实现下面这种回弹的方向</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213337.png" alt="20210702213337"></p>
<p>我们要给Ball脚本添加一个OnCollisionEnter2D方法，用来处理碰撞到物体时的回弹角度</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702213407.png" alt="20210702213407"></p>
<p>上面这个图是展示各个方向的向量值<br>我们要确定的是，弹到球拍上方，中间和下方的向量值，比较发现，上中下是根据Y轴的值来区分的，而且都在-1到1的区间内，我们通过下面的方式来计算<br>|| 1 &lt;- at the top of the racket
||
|| 0 &lt;- at the middle of the racket
||
|| -1 &lt;- at the bottom of the racket</p>
<p>那我们通过什么来确认球的Y轴值呢，这里的Y轴值不是指Y轴的坐标，而是只计算回弹方向的Y轴值，很明显，我们是球打在球拍上，球相对与球拍的位置，就是确认回弹方向的Y轴值，所以我们可以通过球拍的高度来计算Y轴值<br>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">hitFactor</span>(<span class="params">Vector2 ballPos, Vector2 racketPos,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">float</span> racketHeight</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ascii art:</span></span><br><span class="line">    <span class="comment">// || 1 &lt;- at the top of the racket</span></span><br><span class="line">    <span class="comment">// ||</span></span><br><span class="line">    <span class="comment">// || 0 &lt;- at the middle of the racket</span></span><br><span class="line">    <span class="comment">// ||</span></span><br><span class="line">    <span class="comment">// || -1 &lt;- at the bottom of the racket</span></span><br><span class="line">    <span class="keyword">return</span> (ballPos.y - racketPos.y) / racketHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在碰撞方法里面分别判断左球拍，和右球拍的回弹计算</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D col</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Note: &#x27;col&#x27; holds the collision information. If the</span></span><br><span class="line">    <span class="comment">// Ball collided with a racket, then:</span></span><br><span class="line">    <span class="comment">// col.gameObject is the racket</span></span><br><span class="line">    <span class="comment">// col.transform.position is the racket&#x27;s position</span></span><br><span class="line">    <span class="comment">// col.collider is the racket&#x27;s collider</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Hit the left Racket?</span></span><br><span class="line">    <span class="keyword">if</span> (col.gameObject.name == <span class="string">&quot;RacketLeft&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Calculate hit Factor</span></span><br><span class="line">        <span class="built_in">float</span> y = hitFactor(transform.position,</span><br><span class="line">        col.transform.position,</span><br><span class="line">        col.collider.bounds.size.y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Calculate direction, make length=1 via .normalized</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(<span class="number">1</span>, y).normalized;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set Velocity with dir * speed</span></span><br><span class="line">        GetComponent&lt;Rigidbody2D&gt;().velocity = dir * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hit the right Racket?</span></span><br><span class="line">    <span class="keyword">if</span> (col.gameObject.name == <span class="string">&quot;RacketRight&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Calculate hit Factor</span></span><br><span class="line">        <span class="built_in">float</span> y = hitFactor(transform.position,</span><br><span class="line">        col.transform.position,</span><br><span class="line">        col.collider.bounds.size.y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Calculate direction, make length=1 via .normalized</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(<span class="number">-1</span>, y).normalized;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set Velocity with dir * speed</span></span><br><span class="line">        GetComponent&lt;Rigidbody2D&gt;().velocity = dir * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了，试试看吧，现在已经可以让球自由的弹来弹去了</p>
<hr>
<p>总结♂<br>在这个教程里，我们学会了安装和使用Unity，能够创建场景，添加文理，运用基本的Unity物理系统和写一些简单的脚本</p>
<p>记住啊，Unity用起来很简单，我们大多时候只需要用鼠标操作，以及些一些简单的脚本，就能够实现很多牛逼的效果，所以不用太害怕去创造新东西。<br>下面列出一堆，你可以继续为这个游戏添加的有趣功能<br>1.给小球添加追踪的效果<br>2.添加音效<br>3.添加一个显示分数<br>4.让球动的越来越快<br>5.加一个AI，现在我们只能左手和右手玩。。。<br>6.添加一个初始菜单和结算界面7.发挥你的想象吧~</p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/b8a642ce/">https://blooddot.cool/posts/b8a642ce/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 2D 乓乓游戏（四）</title>
    <url>/posts/d7388789/</url>
    <content><![CDATA[<p>【非原创2D游戏教程】乓乓游戏
<a href="https://blooddot.cool/posts/dbdef186/">教程目录地址</a></p>
<a id="more"></a>

<p>对了，还要重命名球拍，Unity自动生成的名字看着实在难受</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702211005.png" alt="20210702211005"></p>
<p>球拍也要加上物理组件Box Collider 2D，别问我为什么，难道你用空气做的球拍打球么</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702211041.png" alt="20210702211041"></p>
<hr>
<p>接下来是个好玩的知识点了，我们在游戏里面是需要控制球拍上下滑动移动坐标的，但当球拍上下移动到撞墙了，我们怎么去做出一个撞墙的效果，让球拍不会跑出墙外面呢
轮到Rigidbody（刚体）登场了，以下是百度百科：</p>
<blockquote>
<p>刚体是指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。绝对刚体实际上是不存在的，只是一种理想模型，因为任何物体在受力作用后，都或多或少地变形，如果变形的程度相对于物体本身几何尺寸来说极为微小，在研究物体运动时变形就可以忽略不计。把许多固体视为刚体，所得到的结果在工程上一般已有足够的准确度。但要研究应力和应变，则须考虑变形。由于变形一般总是微小的，所以可先将物体当作刚体，用理论力学的方法求得加给它的各未知力，然后再用变形体力学，包括材料力学、弹性力学、塑性力学等的理论和方法进行研究。</p>
</blockquote>
<p>我们可以给有刚体的物体添加各种属性实现很多效果，比如可以给它添加重力，让物体能够自由落体啦，让物体碰撞到添加了碰撞体的物体后不能继续穿墙移动啦
一般来说，使用了物理组件的话，移动的物体一般都要添加Rigidbody（刚体）组件的，有人要问为什么了，我也不知道，原文没写哈哈哈（我猜是一般物理游戏移动的东西都不能穿墙或者穿地面吧）</p>
<p>我们选中那两块球拍，然后在Inspector（检视）面板里面依次按以下顺序添加Rigidbody 2D组件 AddComponent-&gt;Physics 2D-&gt;Rigidbody 2D。然后修改Rigidbody 2D属性，把Gravity（重力）设为0，因为我们在平面上控制球拍，并不需要球拍自由落体般下落，然后勾选Freeze Rotation Z（冻结Z轴旋转），为了让球拍碰撞后不旋转，然后设置Collision Detection（碰撞检测）为Continuous（持续的），并且设置Interpolate为Interpolate（内插值），查了一下，设置后可以基于上一帧的变换来平滑本帧变换，差不多就是移动的时候看起来顺畅一点，没有卡的意思。</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212025.png" alt="20210702212025"></p>
<p>好了，接下来开始写代码了，怕不怕━((<em>′д｀)爻(′д｀</em>))━!!!!<br>我们需要写一个脚本来控制球拍的移动，选中球拍，然后在右边的Inspector（检视）面板里面添加脚本 Add Component-&gt;New Script，取名叫MoveRacket，移动球拍的意思，选择CSharp语言</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212131.png" alt="20210702212131"></p>
<p>我们在Project（项目）面板双击打开创建的脚本，打开后差不多是这个样子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveRacket</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面有两个方法，Start方法是这个类初始化的时候运行的，就是你把这个脚本绑定在哪个物体上，当这个物体创建后，这个Start方法就会运行，然后这个Update方法是会一直运行的，大概是每秒运行60次的样子，反正根据设置的帧频来的</p>
<p>但Update方法有个缺点，就是你游戏卡的时候，我们一般叫掉帧，也就掉帧频啦，Update是根据帧频来计算运行的次数的，那么帧频掉了，Update方法当然执行的次数就会不太准，对于我们这种要实时计算碰撞的游戏来说是不太好的<br>所以轮到FixedUpdate方法出现了，Fixed是固定的意思，那么这个方法我们也就可以猜到了，就是不管我们游戏帧频怎么样算，这个方法都是在固定的时间点执行的，不会受影响，对于物理游戏来说，这个方法是再好不过的了。</p>
<p>好，我们把Start方法和Update方法删了（反正用不到，占着位置干嘛，我又不是靠代码行数来算工资的），然后写一个FixedUpdate方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveRacket</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个名字啊，不要弄错了啊，如果你是用的VS来写代码，可以用Ctrl+Shift+M快捷键来创建一些Unity内置的方法，这样就不用自己手打名字，也就不会搞错啦^o^不要忘记了我们创建这个代码是为了让球拍移动的，由于球拍添加了Rigidbody，所以我们可以用Rigidbody来移动球拍，Rigidbody里面有个属性叫velocity，就是刚体的速度向量，我摘抄一段圣典里面的话
在大多数情况下，你不应该直接修改速度，因为这会导致不真实的行为。在每个物理步，不要再每个物体的速度，这将导致不真实的物理模拟。一个典型的例子，当你在第一人称射击游戏中使用跳跃的时候改变速度，因为你想立即改变速度。<br>但我们这个不是真是的物理模拟啊，我只是要让拍子在游戏里上下移动而已，我又不管重力什么的。这玩意里面既然有个向量的单词，那肯定是向量啦，我们来复习一下向量是啥（其实就是XY坐标）</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212344.png" alt="20210702212344"></p>
<p>一目了然吧，我们要上下移动，所以要给球拍一个向上或是向下的向量，其实就是Y轴的向量然后有人要问了，我们这个向量哪里可以得到啊<br>所以说Unity引擎很好呢，引擎里面有个Input类，里面提供了一系列方法获取用户输入的信息，我们这次就用GetAxisRaw这个方法，直译就是获取原始轴，大致就是用户通过输入控制器提供改变坐标轴的值，然后用这个方法来获取控制器改变的坐标轴的值。<br>我们回到编辑器，依照下列顺序打开InputManager，Edit-&gt;Project Settings-&gt;Input</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212414.png" alt="20210702212414"></p>
<p>可以看到一个列表，其实这些都是输入控制器，我们这次就用默认自带的Vertical来控制球拍吧<br>写两句代码来移动球拍吧</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveRacket</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> axis = <span class="string">&quot;Vertical&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">float</span> v = Input.GetAxisRaw(axis);</span><br><span class="line">        GetComponent&lt;Rigidbody2D&gt;().velocity = <span class="keyword">new</span> Vector2(<span class="number">0</span>, v) * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们通过Input.GetAxisRaw来获取了一个输入值，然后复制给Rigidbody2D的速度向量Y坐标上，看了上面的向量图可以知道，赋值为正是向上移动，赋值为负是向下移动。我们再回过头来看输入控制器的截图可以发现“S”键对应的是Negative Button，“W”键对应的是Positive Button，Negative数学里翻译是负的意思，也就是S是输入负值，Positive数学里翻译是正的意思，那么W就是正值了，所以赋值给Rigidbody2D的速度向量后，按“S”键是向下移动，“W”键是向上移动，和我们习惯的操作一样，真方便啊~</p>
<p>然后speed是控制移动的速度，我们先设置为30吧。我们来运行一下游戏，发现可以通过S和W键来控制球拍的移动了，是不是有点小激动啊</p>
<p>给两块球拍添加不同的输入控制器但是我们只是想控制单块球拍的移动啊，如果用一个控制器控制两块球拍，玩个球啊，打着多没意思啊
那现在就要给两块球拍添加不同的控制器了，也很简单
我们在控制器页面输入控制器的数量，多加一位，并把新的控制器命名为Vertical2，设置方向键控制正负按钮</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212540.png" alt="20210702212540"></p>
<p>然后再选中右边的板子，在Inspector（检视）面板里，将Script组件里的Axis属性换成Vertical2<br>跑一下，哦耶，我们可以左手控制左球拍右手控制右球拍了~</p>
<p><img src="https://raw.githubusercontent.com/blooddot/FigureBed/master/blog/20210702212650.gif" alt="20210702212650"></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/d7388789/">https://blooddot.cool/posts/d7388789/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>【非原创2D游戏教程】乓乓游戏</title>
    <url>/posts/dbdef186/</url>
    <content><![CDATA[<p>原帖链接:<a href="https://tieba.baidu.com/p/4991749471?pid=104433992759&amp;cid=#104433992759">https://tieba.baidu.com/p/4991749471?pid=104433992759&amp;cid=#104433992759</a></p>
<a id="more"></a>

<p>写在开头的碎碎念：<br>做了几年的游戏，因为很讨厌大学时教C#的老师，所以对Unity一直没啥兴趣。但想了好久了（大概两年？），还是想做自己想要的游戏，因为一直喜欢玩2D的游戏，并且2D游戏成本低一点，所以想着今年学一学Unity3D，再画多点时间学一学美术，能出一款自己的游戏。<br>这几个月都在用零碎的时间看Unity3D相关的东西，觉得下面这个网站的2D教程都很不错，所以自己先照着网站的教程写了一下demo，觉得对于Unity3D开发2D很有帮助。因为网站是英文的，我在逛了下贴吧，发现好多都是初学者，所以用自己蹩脚的翻译大致翻译了一下教程，一是为了自己记录查看方面，二是希望能够帮助一下热爱游戏的初学者们，翻译有问题的地方还欢迎大家指正。</p>
<p>游戏原文教程出处：<a href="https://noobtuts.com/unity/2d-pong-game">https://noobtuts.com/unity/2d-pong-game</a><br>我把自己做好的demo放到了国内最大的同性交流平台网站上，基佬嗨皮网，供大家参考：
<a href="https://github.com/BloodDot/project4unity/tree/master/Pong">https://github.com/BloodDot/project4unity/tree/master/Pong</a></p>
<p>教程目录</p>
<p><a href="https://blooddot.cool/posts/1d1dd166/">Unity 2D 乓乓游戏（一）</a></p>
<p><a href="https://blooddot.cool/posts/2d0b3dbe/">Unity 2D 乓乓游戏（二）</a></p>
<p><a href="https://blooddot.cool/posts/60159eec/">Unity 2D 乓乓游戏（三）</a></p>
<p><a href="https://blooddot.cool/posts/d7388789/">Unity 2D 乓乓游戏（四）</a></p>
<p><a href="https://blooddot.cool/posts/b8a642ce/">Unity 2D 乓乓游戏（五）</a></p>
<p>本文作者：雪糕<br />本文地址： <a href="https://blooddot.cool/posts/dbdef186/">https://blooddot.cool/posts/dbdef186/</a> <br />版权声明：转载请注明出处！</p>
]]></content>
      <categories>
        <category>黑历史</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
</search>
